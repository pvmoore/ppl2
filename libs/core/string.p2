@module(priority=-900_000)

public

//=================================================================================================
// Standard or small string
//=================================================================================================
struct string { // 16 bytes
    byte* basePtr
    int offset
readonly
    int length
public 
    new { byte* ptr, int offset, int len ->
        this.basePtr = ptr
        this.offset  = offset
        this.length  = len
    }
    ptr   { return basePtr+offset }
    empty { return length==0 }
    first { assert not empty; return ptr()[0] }
    last  { assert not empty; return ptr()[length-1] }
    
    operator[] { int index-> return ptr()[index] }
    
    operator== { string s -> 
        return length==s.length and memcmp(ptr(), s.ptr(), length) == 0 
    } 
    //operator< { string s -> return todo }
           
    indexOf { int ch ->
        var p = memchr(ptr(), ch, length)
        return if(p) (p-ptr()) as int else -1
    }
    contains { int ch ->
        return indexOf(ch) <> -1   
    }
    startsWith { int ch ->
        return length>0 and ptr()[0]==ch   
    }
    startsWith { string s ->
        return length >= s.length and memcmp(ptr(), s.ptr(), s.length) == 0           
    }
    endsWith { int ch ->
        return length>0 and ptr()[length-1]==ch 
    }
    endsWith { string s ->
        if(s.length==0) return false
        var off = length-s.length;
        return length >= s.length and memcmp(ptr()+off, s.ptr(), s.length) == 0   
    }
}
//=================================================================================================
// Large string
//=================================================================================================
struct lstring { // 24 bytes
    byte* basePtr
    long offset
readonly
    long length
public
        
}
    
private    
new {
    assert #sizeof(string)==16   
    assert #sizeof(lstring)==24   
}
