
private
struct Vector = <T> [
    T x
    T y
    T z

    new = { T a, T b, T c -> x=a y=b z=c }
    new = { T a -> x=a y=a z=a }

    operator+ = { T s -> return Vector<T>(x+s, y+s, z+s) }
    operator- = { T s -> return Vector<T>(x-s, y-s, z-s) }
    operator* = { T s -> return Vector<T>(x*s, y*s, z*s) }
    operator/ = { T s -> return Vector<T>(x/s, y/s, z/s) }
    operator% = { T s -> return Vector<T>(x%s, y%s, z%s) }
    operator<< = { T s -> return Vector<T>(x<<s, y<<s, z<<s) }
    operator>> = { T s -> return Vector<T>(x>>s, y>>s, z>>s) }
    operator>>> = { T s -> return Vector<T>(x>>>s, y>>>s, z>>>s) }
    operator| = { T s -> return Vector<T>(x|s, y|s, z|s) }
    operator& = { T s -> return Vector<T>(x&s, y&s, z&s) }
    operator^ = { T s -> return Vector<T>(x^s, y^s, z^s) }

    operator<> = { T s ->
        return if(x==s or y==s or z==s) 0 else
               if(x<s or y<s or z<s) -1 else 1
    }

    operator neg = { return Vector<T>(-x,-y,-z) }

    // get
    operator[] = { int index ->
        return if(index==0) x else
               if(index==1) y else z
    }
    // set
    operator[] = { int index, T value ->
        @(if(index==0) &x else
          if(index==1) &y else &z) = value
    }

    operator+ = { Vector<T> v -> return Vector<T>(x+v.x, y+v.y, z+v.z) }
    operator- = { Vector<T> v -> return Vector<T>(x-v.x, y-v.y, z-v.z) }
    operator* = { Vector<T> v -> return Vector<T>(x*v.x, y*v.y, z*v.z) }
    operator/ = { Vector<T> v -> return Vector<T>(x/v.x, y/v.y, z/v.z) }
    operator% = { Vector<T> v -> return Vector<T>(x%v.x, y%v.y, z%v.z) }
    operator<< = { Vector<T> v -> return Vector<T>(x<<v.x, y<<v.y, z<<v.z) }
    operator>> = { Vector<T> v -> return Vector<T>(x>>v.x, y>>v.y, z>>v.z) }
    operator>>> = { Vector<T> v -> return Vector<T>(x>>>v.x, y>>>v.y, z>>>v.z) }
    operator| = { Vector<T> v -> return Vector<T>(x|v.x, y|v.y, z|v.z) }
    operator& = { Vector<T> v -> return Vector<T>(x&v.x, y&v.y, z&v.z) }
    operator^ = { Vector<T> v -> return Vector<T>(x^v.x, y^v.y, z^v.z) }

    operator<> = { Vector<T> v ->
        return if(x==v.x and y==v.y and z==v.z) 0 else
               if(x<v.x) -1 else
               if(y<v.y) -1 else
               if(z<v.z) -1 else 1
    }

    operator+=  = { T s -> x += s y += s z += s }
    operator-=  = { T s -> x -= s y -= s z -= s }
    operator*=  = { T s -> x *= s y *= s z *= s }
    operator/=  = { T s -> x /= s y /= s z /= s }
    operator%=  = { T s -> x %= s y %= s z %= s }
    operator<<= = { T s -> x <<= s y <<= s z <<= s }
    operator>>= = { T s -> x >>= s y >>= s z >>= s }
    operator>>>= = { T s -> x >>>= s y >>>= s z >>>= s }
    operator|= = { T s -> x |= s y |= s z |= s }
    operator&= = { T s -> x &= s y &= s z &= s }
    operator^= = { T s -> x ^= s y ^= s z ^= s }

    operator+= = { Vector<T> v -> x+=v.x y+=v.y z+=v.z }
    operator-= = { Vector<T> v -> x-=v.x y-=v.y z-=v.z }
    operator*= = { Vector<T> v -> x*=v.x y*=v.y z*=v.z }
    operator/= = { Vector<T> v -> x/=v.x y/=v.y z/=v.z }
    operator%= = { Vector<T> v -> x%=v.x y%=v.y z%=v.z }
    operator<<= = { Vector<T> v ->  x<<=v.x  y<<=v.y  z<<=v.z }
    operator>>= = { Vector<T> v ->  x>>=v.x  y>>=v.y  z>>=v.z }
    operator>>>= = { Vector<T> v -> x>>>=v.x y>>>=v.y z>>>=v.z }
    operator|= = { Vector<T> v -> x|=v.x y|=v.y z|=v.z }
    operator&= = { Vector<T> v -> x&=v.x y&=v.y z&=v.z }
    operator^= = { Vector<T> v -> x^=v.x y^=v.y z^=v.z }

    test = {
        var v = operator+(2)
        assert v.x==2 and v.y==2 and v.z==2
    }
]

public
testOperatorOverloading = {
    value = {
        scalars = {
            Vector<int> v
            assert v.x==0 and v.y==0 and v.z==0

            var v2 = v + 1
            assert v2.x==1  and v2.y==1  and v2.z==1
            var v3 = v - 1
            assert v3.x==-1 and v3.y==-1 and v3.z==-1
            var v4 = v2 * 2
            assert v4.x==2 and v4.y==2 and v4.z==2
            var v5 = v4 / 2
            assert v5.x==1 and v5.y==1 and v5.z==1
            var v6 = Vector<int>(10) % 4
            assert v6.x==2 and v6.y==2 and v6.z==2
            var v7 = Vector<int>(1) << 1
            assert v7.x==2 and v7.y==2 and v7.z==2
            var v8 = Vector<int>(0xffffffff as int) >> 1
            assert v8.x==-1 and v8.y==-1 and v8.z==-1
            var v9 = Vector<int>(0xffffffff as int) >>> 1
            assert v9.x==0x7fffffff and v9.y==0x7fffffff and v9.z==0x7fffffff
            var v10 = Vector<int>(0) | 0b111
            assert v10.x==7 and v10.y==7 and v10.z==7
            var v11 = Vector<int>(0b110) & 0b111
            assert v11.x==6 and v11.y==6 and v11.z==6
            var v12 = Vector<int>(0b110) ^ 0b111
            assert v12.x==1 and v12.y==1 and v12.z==1
            var v13 = Vector<int>(0)
            // <>
            assert v13 == 0
            assert v13 <> 1
            assert v13 < 1
            assert v13 <= 0
            assert v13 > -1
            assert v13 >= 0

            // :
            assert Vector<int>(1,2,3)[0] == 1    // get
            var v14 = Vector<int>(1,2,3)
            v14[0] = 2   // set
            assert v14[0] == 2   // get

            var b = Vector<int>()
            assert b.x==0 and b.y==0 and b.z==0
            b += 1
            assert b.x==1 and b.y==1 and b.z==1
            b -= 10
            assert b.x==-9 and b.y==-9 and b.z==-9
            b *= 2
            assert b.x==-18 and b.y==-18 and b.z==-18
            b /= 2
            assert b.x==-9 and b.y==-9 and b.z==-9
            b %= 2
            assert b.x==-1 and b.y==-1 and b.z==-1
            b = Vector<int>(1)
            b <<= 2
            assert b.x==4 and b.y==4 and b.z==4
            b = Vector<int>(-1)
            b >>= 1
            assert b.x==-1 and b.y==-1 and b.z==-1
            b >>>= 1
            assert b.x==0x7fffffff and b.y==0x7fffffff and b.z==0x7fffffff
            b = Vector<int>(0b110)
            b |= 0b111
            assert b.x==7 and b.y==7 and b.z==7
            b = Vector<int>(0b110)
            b &= 0b111
            assert b.x==6 and b.y==6 and b.z==6
            b = Vector<int>(0b110)
            b ^= 0b111
            assert b.x==1 and b.y==1 and b.z==1
        }
        structs = {
            define Vec = Vector<int>

            var a1 = Vec(1) + Vec(1,2,3)
            assert a1 == Vec(2,3,4)

            assert Vec(10) - Vec(1,2,3) == Vec(9,8,7)
            assert Vec(10) * Vec(1,2,3) == Vec(10,20,30)
            assert Vec(10) / Vec(1,2,3) == Vec(10,5,3)
            assert Vec(10) % Vec(2,3,4) == Vec(0,1,2)

            assert Vec(1,2,4)    << Vec(1,2,3) == Vec(2,8,32)
            assert Vec(-1,-2,-4) >> Vec(1,1,1) == Vec(-1,-1,-2)
            assert Vec(-1,-4,-16) >>> Vec(1,2,3) == Vec(0x7fff_ffff, 0x3fff_ffff, 0x1fff_fffe)

            assert Vec(0b101) | Vec(1, 0b11, 0b111) == Vec(0b101, 0b111, 0b111)
            assert Vec(0b101) & Vec(1, 0b11, 0b111) == Vec(1,         1, 0b101)
            assert Vec(0b101) ^ Vec(1, 0b11, 0b111) == Vec(0b100, 0b110, 0b010)

            // neg
            assert -Vec(1,2,3) == Vec(-1,-2,-3)

            // <>
            assert Vec(0) < Vec(1)
            assert Vec(0) <= Vec(0)
            assert Vec(0) > Vec(-1)
            assert Vec(0) >= Vec(0)
            assert Vec(0) <> Vec(1)
        }
        scalars()
        structs()

        var vv = Vector<float>().operator+(1)
        assert vv.x==1 and vv.y==1 and vv.z==1
    }
    ptr = {
        var v = Vector<float>*()
        assert v.x==0 and v.y==0 and v.z==0

        var v3 = v.operator+(1)
    }
    internal = {
        var v = Vector<float>()
        v.test()
    }
    value()
    ptr()
    internal()
}
