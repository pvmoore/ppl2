
/*
import core.c

//import notfound

S = [
    int a = 'A'
    float b = 1
    new = {

    }
    new = { int v ->

    }
]

main = {
    //S s    = S('B')

    S* ptr = S*('C')

    putchar(ptr.a)
}
*/

import core.c
import core.string
//import c = core.c

import test_imports
import test_literals
import test_arrays
import test_expressions
import test_structs
import test_casting
import test_closures
import test_consts
import test_constructors
import test_meta
import test_literal_struct
import test_unreferenced_module

define AA = int
define BB = AA*
define CC = BB
define DD = CC*
DD dd           // int**

Gold = []

Silver = [
    Gold* gold
]
Gold = [
    Silver* silver
]
Gold gold

// Module init function
new = {
    // All module variable initialisation code will be put in here
    boop += 7
}

Goal = [
    int scorer
]

Animal = [
    int age
    [:int 4] s
    Goal g
    [int,bool] anon
    bark = { // Animal* this

    }
]

define GreyWolf  = Wolf
define AnimalPtr = Animal*
define IntPtr    = int*

dothings = { int a, Cat cat ->
    int local
    return cat
}

int boop = 1

define Unref = int

Unref unr = 77

unreferencedFunc = {
    [bool,bool] a
}

Thingy = [
    int a

    // fixme - This needs to be coerced {void->byte} to {void->int}
    //{void->int} b = { return 1 }

    //new = { Thingy* This }    // implicit
]

myfunc = { bool flag ->
    return flag
}

someArrays = {
    [:int 5] array
    var a2 = [: 1,2]
    var a3 = [: 3=999]
}

main = {
    int a = 3
    int b = a - 2

    myfunc(true)

    [int, float] anon

    assert true

    GreyWolf wolf
    Animal* animal
    Animal** animal2
    AnimalPtr animalPtr
    IntPtr ip

    Cat cat
    Dog* dog
    //dog.age += 1

    [int, Bat berty] bertyStruct

    int a = 1
    var b = 2

    Thingy thingy
    thingy.a = 9

    someArrays()

    importedFunc()

    testLiterals()
    testExpressions()
    testCasting()
    testConsts()
    testMeta()
    //testArrays()

    testStructs()
    //testClosures()
    //testConstructors()
    //testLiteralStruct()

    dothings(0, cat)

    putchar('a')

    Dog* dd = null
    dd = dog
    dd = null

    // broken
    //puts("Hi there".ptr)

/*
    // inferred return type
    // {void->}
    // {void->var}
    // {->}
    {bool->} funcptr = { bool b ->
        // do the thing
        return 99
    }

    // Fixme - this is unknown and is replaced. It needs to be
    // coerced if possible, if not then an error shown
    {var->} hello = { int a -> return 700 }

    // call the function ptr
    funcptr(true)

    {void->Pig**} piggywiggy
    {void->Pig} piggywiggy2


    var a = null as Pig*

    [:Bat 3] zz

    int inty
    {void->void} funky
    Bat batty
    Bat* battyptr
    [:int 1] arrayy
    [int a,bool b] structy

    int* ptr

    //var v0 =
    ptr:0

    define Wazzer = float
    define Zipper = Wazzer
    define Zippers = Zipper*

    //Wazzer myWazzer
    //Zipper zipper
    //Zippers zips
    */

}
bool yop



//Animal = [
//    int a
//    int b
//    foo = { int c -> return true }
//]
//Dog = Animal
//K = int
//K z = 7
//var a = 0
//var b = a
//int c
//[bool,bool] someBools
//bool result = false

////////////////////////////////////////////////////////////////////////////
/*
Dog = [
    int a
    int b

    var f = { int c -> return true }


]
Dog dog = [1,2]
*/


/*
{void->int} ff = {
    return 1
}

module = {

}

doit = {

}

bool flag = true
var ch = '\n'

main = {
    int a
    int b = 1
    //var c = 2

    // to resolve
    int d = a+b

    ff()
}
*/

/*
//----------------------------------------- imports
import core
    thing1,
    thing2
//----------------------------------------- defines
public

K = int
L = K
M = {int->bool}
N = [int:10]   // static array
SS = <T> [
private             // only visible within this module
    T a
    int d
readonly            // read only outside this module, read/write inside
    float b
public              // read and write outside this module
    [int,float] c

    // this is a function variable
    {int->bool} foo = { wibble ->
        import core thing3
        return true
    }
    // This is a struct variable with an implicit this*
    // {SS* this, int foo -> int}
    func = { int foo ->
        define R = float
        return 0
    }
]
private D = [float a]
E = double

//----------------------------------------- module variables

// All module scope vars are private
// All module scope vars must either:
//      1) Have no initialiser
//      2) Have a simple initialiser or
//      3) Have a parenthesised initialiser
// Move all initialisation into module function but leave declarations.
[int] Y
[bool,int] Z      = [true,9]
int G1            = 3 + 1
{int->int} func2  = { a -> return 1 }
{int->void} func3 = { it -> }

//----------------------------------------- functions
module = {  // module initialiser
    int a
    int b = 0

    //Y = [0]
    //Z = [true,0]
    //G1 = 4
    //func2 = { a -> return a }
    //func3 = { a -> }
}
main = {    // {void->void}
    //int a = 0
    //var b = 1

    //SS ss = SS()
    //var s2 = SS*()

    //var s3 = as<int>(3.4)

    //if(a==0) {
    //} else {
    //}
}
min = <T> { T a, T b ->
    return a
}
min = <T> { T a, T b, T c ->
    return 0
}
*/
