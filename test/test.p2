
/*
main {
    import test_implicit_template_funcs
    testImplicitTemplateFunctions()
} 
*/


var s = "hello"

import test_imports, test_literals
import test_arrays, test_expressions, test_structs
import test_casting, test_inner_functions, test_consts
import test_constructors, test_meta, test_literal_struct
import test_unreferenced_module, test_calls, test_if
import test_loop, test_template_functions, test_statics

alias AA = int 
alias BB = AA*     // int*
alias CC = BB      // int*
alias DD = CC*     // int**
DD dd               // int**
alias EE = IntPtrPtr*
EE ee               // int*** 

// declare for later
struct Gold
struct Gold // ok 

struct Silver {
    Gold* gold
}
struct Gold { // definition
    Silver* silver
}
Gold gold

// Module init function
new  {
    // All module variable initialisation
    // code will be put in here
    boop += 7
}

struct Goal {
    int scorer
}

struct Animal {
    int age
    int[4] s
    Goal g
    [int,bool] anon
    bark { // Animal* this
        assert true
    }
}

alias GreyWolf  = Wolf
alias AnimalPtr = Animal*
alias IntPtr    = int*

dothings { int a, Cat cat ->
    int local
    return cat
}

int boop = 1

alias Unref = int

Unref unr = 77

unreferencedFunc {
    [bool,bool] a
}

struct Thingy {
    int a
    {void->int} b = { return 1 }

    //new = { Thingy* this }    // implicit
}

myfunc { bool flag ->
    return flag
}

someArrays {
    int[5] array
    var a2 = [: 1,2]
    var a3 = [: 3=999]
}

struct Array <A,B> {
    A a
    B b
}

main {
    import test_operator_overloading
    
    testLiterals()
    testExpressions()
    testCasting()
    testConsts()
    testMeta()
    testArrays()

    testStructs()
    testInnerFunctions()
    testConstructors()
    testLiteralStruct()
    testCalls()
    testIf()
    testLoop()
    testTemplateFunctions()
    testOperatorOverloading()
    testStatics()
	testImports()
    
    import test_implicit_template_funcs
    testImplicitTemplateFunctions()

    testGlobals {
        assert dd is int**
        assert ee is int***
    }
    test0 {
        int a1 = 3
        int b1 = a1 - 2

        myfunc(true)

        [int, float] anon

        GreyWolf wolf
        Animal* animal
        Animal** animal2
        AnimalPtr animalPtr
        IntPtr ip
        
        var animal3 = Animal()
        animal3.bark()

        Cat cat
        Dog* dog = Dog*()
        dog.age += 1

        [int, Bat berty] bertyStruct

        int a = 1
        var b = 2

        Thingy thingy = Thingy()
        thingy.a = 9

        someArrays()

        importedFunc()

        dothings(0, cat)

        Dog* dd1 = null
        dd1 = dog
        dd1 = null
    }
    test1 {
        {void->int} b = { return 1 }
    }
    test2 {
        {void->[int a,int b]} f = {
            return [1,2]
        }

        var r = f()
        [int a, float b] r2 = r as [int,float]

        var a = r.a
        var b = r.b
        assert a==1
        assert b==2

        assert r2.a==1

        // reinterpret cast int to float won't be 2
        //assert r2.b==2
    }
    test3 {
        struct Listy <T> {
            T length
        }

        Listy<int> list = Listy<int>()
        Array<int,float> array
        Rose<int> rose
        ANiceRose anicerose
        Listy<BlueRose> blueList
        Listy<Listy<int>> listoflist
    }
    test4 {
        //float2 v2
        //float3 v3
        //float4 v4
        //float8 v8
    }
    testInnerImport {
        import test_imports3

        assert 77 == i3func()
        I3Object obj = I3Object()
    }

    testGlobals()
    test0()
    test1()
    test2()
    test3()
    test4()
    testInnerImport()

    import test_access
    testAccess()

    import test_list
    testList()
    import test_console
    testConsole()
}
bool yop








/*
    // inferred return type
    // {void->}
    // {void->var}
    // {->}
    {bool->} funcptr = { bool b ->
        // do the thing
        return 99
    }

    // Fixme - this is unknown and is replaced. It needs to be
    // coerced if possible, if not then an error shown
    {var->} hello = { int a -> return 700 }

    // call the function ptr
    funcptr(true)

    {void->Pig**} piggywiggy
    {void->Pig} piggywiggy2


    var a = null as Pig*

    [:Bat 3] zz

    int inty
    {void->void} funky
    Bat batty
    Bat* battyptr
    [:int 1] arrayy
    [int a,bool b] structy

    int* ptr

    //var v0 =
    ptr:0

    alias Wazzer = float
    alias Zipper = Wazzer
    alias Zippers = Zipper*

    //Wazzer myWazzer
    //Zipper zipper
    //Zippers zips
    */////////////////////////////////////////////////////////////////





//Animal = [
//    int a
//    int b
//    foo = { int c -> return true }
//]
//Dog = Animal
//K = int
//K z = 7
//var a = 0
//var b = a
//int c
//[bool,bool] someBools
//bool result = false

////////////////////////////////////////////////////////////////////////////
/*
alias Dog = [
    int a
    int b
]
Dog dog = [1,2]
*///////////////////////////////////////////////


/*
public

K = int
L = K
M = {int->bool}
N = [int:10]   // static array
SS = <T> [
private             // only visible within this module
    T a
    int d
readonly            // read only outside this module, read/write inside
    float b
public              // read and write outside this module
    [int,float] c

    // this is a function variable
    {int->bool} foo = { wibble ->
        import core thing3
        return true
    }
    // This is a struct variable with an implicit this*
    // {SS* this, int foo -> int}
    func = { int foo ->
        alias R = float
        return 0
    }
]
private D = [float a]
E = double

//----------------------------------------- module variables

// All module scope vars are private
// All module scope vars must either:
//      1) Have no initialiser
//      2) Have a simple initialiser or
//      3) Have a parenthesised initialiser
// Move all initialisation into module function but leave declarations.
[int] Y
[bool,int] Z      = [true,9]
int G1            = 3 + 1
{int->int} func2  = { a -> return 1 }
{int->void} func3 = { it -> }

//----------------------------------------- functions
module = {  // module initialiser
    int a
    int b = 0

    //Y = [0]
    //Z = [true,0]
    //G1 = 4
    //func2 = { a -> return a }
    //func3 = { a -> }
}
main = {    // {void->void}
    //int a = 0
    //var b = 1

    //SS ss = SS()
    //var s2 = SS*()

    //var s3 = as<int>(3.4)

    //if(a==0) {
    //} else {
    //}
}
min = <T> { T a, T b ->
    return a
}
min = <T> { T a, T b, T c ->
    return 0
}
*///////////////////////////////////////////////
